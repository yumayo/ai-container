#!/bin/bash

# 1つのエントリーをAI_IGNOREに追加
__aicontainer_add_ignore_entry() {
  local host_path="$1"
  local container_path="$2"
  local message="$3"

  # 重複チェック
  if [ -n "${AI_IGNORE_PATHS[$container_path]}" ]; then
    echo "ignored (already): $message"
    return
  fi

  if [ -d "$host_path" ]; then
    AI_IGNORE="$AI_IGNORE \\
    --mount type=tmpfs,target=$container_path,tmpfs-size=0"
    AI_IGNORE_PATHS[$container_path]=1
    echo "ignored: $message"
  elif [ -f "$host_path" ]; then
    AI_IGNORE="$AI_IGNORE \\
    --mount type=bind,source=/dev/null,target=$container_path,readonly"
    AI_IGNORE_PATHS[$container_path]=1
    echo "ignored: $message"
  fi
}

# .aiignoreファイルを処理（base_dirとmount_dstを指定）
__aicontainer_process_aiignore_file() {
  local aiignore_file="$1"
  local base_dir="$2"
  local mount_dst="$3"

  echo "found .aiignore: $aiignore_file"

  local aiignore_dir="$(dirname "$aiignore_file")"

  while IFS= read -r line || [ -n "$line" ]; do
    line="${line%$'\r'}"

    # 空行とコメント行をスキップ
    if [ -z "$line" ]; then
      continue
    fi
    if [[ "$line" =~ ^[[:space:]]*# ]]; then
      continue
    fi

    # パスの正規化
    line="${line#/}"
    local host_full_path="$aiignore_dir/$line"

    # マウント先でのパスを計算
    local rel_path="${host_full_path#$base_dir}"
    rel_path="${rel_path#/}"
    local container_path="$mount_dst/$rel_path"

    __aicontainer_add_ignore_entry "$host_full_path" "$container_path" "$container_path"
  done < "$aiignore_file"
}

# ディレクトリ内の.aiignoreを再帰的に処理
__aicontainer_find_and_process_aiignores() {
  local src_dir="$1"
  local mount_dst="$2"

  while read -r aiignore_file; do
    __aicontainer_process_aiignore_file "$aiignore_file" "$src_dir" "$mount_dst"
  done < <(find "$src_dir" -name .aiignore -type f)
}

# .aicontainerファイルを解析してAICONTAINER_CONFIG連想配列に設定
__aicontainer_parse_config() {
  local config_file=".aicontainer"

  if [ ! -f "$config_file" ]; then
    return
  fi

  echo "found .aicontainer: loading configuration..."

  while IFS= read -r line || [ -n "$line" ]; do
    line="${line%$'\r'}"
    [ -z "$line" ] && continue
    [[ "$line" =~ ^[[:space:]]*# ]] && continue
    [[ "$line" =~ ^[[:space:]]*$ ]] && continue

    if [[ "$line" =~ ^[[:space:]]*([a-zA-Z_][a-zA-Z0-9_]*)[[:space:]]*=[[:space:]]*(.*)[[:space:]]*$ ]]; then
      local key="${BASH_REMATCH[1]}"
      local value="${BASH_REMATCH[2]}"
      if [[ "$value" =~ ^\"(.*)\"$ ]] || [[ "$value" =~ ^\'(.*)\'$ ]]; then
        value="${BASH_REMATCH[1]}"
      fi
      AICONTAINER_CONFIG["$key"]="$value"
      echo "  config: $key=$value"
    fi
  done < "$config_file"
}

# Dockerネットワークが存在しない場合は作成する
__aicontainer_ensure_network() {
  local net_name="$1"
  if ! docker network inspect "$net_name" &>/dev/null; then
    echo "creating docker network: $net_name"
    docker network create "$net_name" &>/dev/null || { echo "Error: failed to create network '$net_name'" >&2; return 1; }
  fi
}

aicontainer() {
  # モードに応じてディレクトリを決定
  local ai_dir=".claude.local"
  if [ "$1" = "ollama" ]; then
    ai_dir=".claude.ollama"
  elif [ "$1" = "codex" ]; then
    ai_dir=".codex.local"
  fi

  # .aicontainerの設定を読み込み
  declare -A AICONTAINER_CONFIG
  __aicontainer_parse_config
  local config_network="${AICONTAINER_CONFIG[network]:-}"
  local config_session="${AICONTAINER_CONFIG[session]:-}"

  # セッションパスの解決（session指定時）
  local session_path=""
  if [ -n "$config_session" ]; then
    if [[ "$config_session" =~ ^/ ]]; then
      session_path="$config_session"
    else
      session_path="$(pwd)/$config_session"
    fi
    mkdir -p "$session_path"
    session_path="$(realpath "$session_path")"
    session_path="${session_path%/}"
    echo "  session path: $session_path"
  fi

  # ディレクトリ構造を作成
  if [ -n "$config_session" ]; then
    # セッションモード: 指定パスにディレクトリ構造を作成
    mkdir -p "$session_path/$ai_dir"
    if [ "$1" != "codex" ]; then
      [ ! -f "$session_path/$ai_dir/.claude.json" ] && echo '{}' > "$session_path/$ai_dir/.claude.json" || true
      mkdir -p "$session_path/$ai_dir/.claude"
    fi
  else
    # ディレクトリモード: 従来のローカルディレクトリを作成
    mkdir -p "$ai_dir"
    if [ "$1" != "codex" ]; then
      [ ! -f "$ai_dir/.claude.json" ] && echo '{}' > "$ai_dir/.claude.json" || true
      mkdir -p "$ai_dir/.claude"
    fi
  fi

  # .envファイルを読み込んで環境変数として設定（docker-compose.ymlと同様の挙動）
  if [ -f .env ]; then
    echo "found .env: loading environment variables..."
    while IFS= read -r line || [ -n "$line" ]; do
      # CRを除去
      line="${line%$'\r'}"
      # 空行をスキップ
      [ -z "$line" ] && continue
      # コメント行をスキップ
      [[ "$line" =~ ^[[:space:]]*# ]] && continue
      # 空白のみの行をスキップ
      [[ "$line" =~ ^[[:space:]]*$ ]] && continue
      # KEY=VALUE形式かチェック
      if [[ "$line" =~ ^[[:space:]]*([a-zA-Z_][a-zA-Z0-9_]*)[[:space:]]*=[[:space:]]*(.*)[[:space:]]*$ ]]; then
        local key="${BASH_REMATCH[1]}"
        local value="${BASH_REMATCH[2]}"
        # 値のクォートを除去（シングル/ダブル）
        if [[ "$value" =~ ^\"(.*)\"$ ]] || [[ "$value" =~ ^\'(.*)\'$ ]]; then
          value="${BASH_REMATCH[1]}"
        fi
        export "$key=$value"
        echo "  loaded: $key"
      fi
    done < .env
  fi

  AI_IGNORE=""
  declare -A AI_IGNORE_PATHS

  # デフォルトのマウント配下の.aiignoreを再帰的に処理
  __aicontainer_find_and_process_aiignores "." "$(pwd)"

  AI_MOUNT=""

  # .aimountを処理
  if [ -f .aimount ]; then
    while IFS= read -r line || [ -n "$line" ]; do
      line="${line%$'\r'}"
      if [ -z "$line" ]; then
        continue
      fi
      if [[ "$line" =~ ^[[:space:]]*# ]]; then
        continue
      fi

      # 先に環境変数を展開してから:で分割
      local expanded_line
      if ! expanded_line="$(eval echo "$line" 2>&1)"; then
        echo "Error: environment variable error: $line" >&2
        echo "  $expanded_line" >&2
        return 1
      fi

      # 展開後の行を:で分割
      IFS=':' read -r src dst <<< "$expanded_line"
      if [ -z "$src" ] || [ -z "$dst" ]; then
        echo "Error: invalid format (expected 'src:dst'): $line" >&2
        return 1
      fi

      # 相対パスを絶対パスに変換し、パスを正規化
      [[ ! "$src" =~ ^/ ]] && src="$(pwd)/$src"

      if [ ! -e "$src" ]; then
        echo "skip mount (not exists): $src"
        return 1
      fi

      src="$(realpath "$src")"

      AI_MOUNT="$AI_MOUNT \\
    --mount type=bind,source=$src,target=$dst"
      echo "mount: $src -> $dst"

      # マウント元ディレクトリ内の.aiignoreを処理
      [ -d "$src" ] && __aicontainer_find_and_process_aiignores "$src" "$dst"
    done < .aimount
  fi

  # 引数チェック
  local dump_mode=false
  local cmd="claude --dangerously-skip-permissions"
  # プレフィックス付与: .aicontainer指定時は yumayo-ai-<name>、未指定時は yumayo-ai
  local network="yumayo-ai"
  if [ -n "$config_network" ]; then
    network="yumayo-ai-$config_network"
  fi
  local extra_env=""
  local extra_opts="--cap-add=NET_ADMIN --cap-add=NET_RAW"
  local shell_prefix="bash"

  if [ "$1" = "dump" ]; then
    dump_mode=true
  elif [ "$1" = "ollama" ]; then
    local model="${2:-}"
    if [ -z "$model" ]; then
      echo "Error: model name required. Usage: aicontainer ollama <model>" >&2
      return 1
    fi
    cmd="claude --dangerously-skip-permissions --model $model"
    extra_env="-e ANTHROPIC_AUTH_TOKEN=ollama -e ANTHROPIC_BASE_URL=http://ollama:11434"
    # https://github.com/yumayo/nginx-open-webui-ollama
    # ネットワークを切り替えています。
    # 完全ローカルで動作させるため、ollamaコンテナで動作させます。
    network="nginx-open-webui-ollama_internal_net"
    extra_opts="--entrypoint bash"
    shell_prefix=""
  elif [ "$1" = "codex" ]; then
    # codex-cli (OpenAI Codex CLI)
    # 認証方法:
    #   1. ChatGPTアカウントでサインイン（Plus/Pro/Business/Enterprise契約者）
    #   2. OPENAI_API_KEYで認証（従量課金）
    # 初回起動時にcodex側でサインインを求められます
    cmd="codex --full-auto"
    extra_env="-e FIREWALL_MODE=codex"
    if [ -n "$OPENAI_API_KEY" ]; then
      extra_env="$extra_env -e OPENAI_API_KEY=$OPENAI_API_KEY"
    fi
  elif [ -n "$1" ]; then
    cmd="$1"
  fi

  # ネットワークが存在しない場合は作成する（dumpモード時はスキップ）
  if [ "$dump_mode" != true ]; then
    __aicontainer_ensure_network "$network" || return 1
  fi

  # dockerコマンドを構築
  local workdir="$(pwd)"
  local session_mounts=""
  local init_cmd=""

  if [ -n "$config_session" ]; then
    # セッションモード: ホストの指定パスをバインドマウント
    if [ "$1" = "codex" ]; then
      session_mounts="--mount type=bind,source=\"$session_path/$ai_dir\",target=/home/ubuntu/.codex"
    else
      session_mounts="--mount type=bind,source=\"$session_path/$ai_dir/.claude\",target=/home/ubuntu/.claude \\
    --mount type=bind,source=\"$session_path/$ai_dir/.claude.json\",target=/home/ubuntu/.claude.json"
    fi
    # セッションパスがワークスペース配下の場合、tmpfsでAIから隠す
    # ~/.claudeはAIから常にアクセス可能だが、ワークスペース内にセッションディレクトリが
    # 存在するとlsやfind等でプロジェクトファイルと誤認される可能性がある。
    # tmpfsで上書きすることで、ワークスペースパス経由の重複アクセスを防ぐ。
    # ワークスペース外のパスはコンテナ内から見えないため対応不要。
    if [[ "$session_path/$ai_dir" == "$workdir"* ]]; then
      session_mounts="--mount type=tmpfs,target=$session_path/$ai_dir,tmpfs-size=0 \\
    $session_mounts"
    fi
  else
    # ディレクトリモード: 従来のローカルディレクトリを使用
    # ワークスペース直下にai_dirが存在するため、AIがプロジェクトファイルと
    # 誤認しないようtmpfsで隠す（実際のデータは~/.claude等に個別マウント済み）
    if [ "$1" = "codex" ]; then
      session_mounts="--mount type=tmpfs,target=$workdir/$ai_dir,tmpfs-size=0 \\
    --mount type=bind,source=\"$workdir/$ai_dir\",target=/home/ubuntu/.codex"
    else
      session_mounts="--mount type=tmpfs,target=$workdir/$ai_dir,tmpfs-size=0 \\
    --mount type=bind,source=\"$workdir/$ai_dir/.claude\",target=/home/ubuntu/.claude \\
    --mount type=bind,source=\"$workdir/$ai_dir/.claude.json\",target=/home/ubuntu/.claude.json"
    fi
  fi

  local docker_cmd="docker run -ti --rm \\
    --stop-timeout 0 \\
    --network $network \\
    -w \"$workdir\" \\
    $extra_env \\
    $extra_opts \\
    --mount type=bind,source=\"$workdir\",target=\"$workdir\" \\
    $session_mounts$AI_MOUNT$AI_IGNORE \\
    yumayo-ai \\
    $shell_prefix -ci \"${init_cmd}$cmd\""

  if [ "$dump_mode" = true ]; then
    echo "$docker_cmd"
  else
    eval "$docker_cmd"
  fi
}
