#!/bin/bash

# 1つのエントリーをAI_IGNOREに追加
__aicontainer_add_ignore_entry() {
  local host_path="$1"
  local container_path="$2"
  local message="$3"

  # 重複チェック
  if [ -n "${AI_IGNORE_PATHS[$container_path]}" ]; then
    echo "ignored (already): $message"
    return
  fi

  if [ -d "$host_path" ]; then
    AI_IGNORE="$AI_IGNORE \\
    --mount type=tmpfs,target=$container_path,tmpfs-size=0"
    AI_IGNORE_PATHS[$container_path]=1
    echo "ignored: $message"
  elif [ -f "$host_path" ]; then
    AI_IGNORE="$AI_IGNORE \\
    --mount type=bind,source=/dev/null,target=$container_path,readonly"
    AI_IGNORE_PATHS[$container_path]=1
    echo "ignored: $message"
  fi
}

# .aiignoreファイルを処理（base_dirとmount_dstを指定）
__aicontainer_process_aiignore_file() {
  local aiignore_file="$1"
  local base_dir="$2"
  local mount_dst="$3"

  echo "found .aiignore: $aiignore_file"

  local aiignore_dir="$(dirname "$aiignore_file")"

  while IFS= read -r line || [ -n "$line" ]; do
    line="${line%$'\r'}"

    # 空行とコメント行をスキップ
    if [ -z "$line" ]; then
      continue
    fi
    if [[ "$line" =~ ^[[:space:]]*# ]]; then
      continue
    fi

    # パスの正規化
    line="${line#/}"
    local host_full_path="$aiignore_dir/$line"

    # マウント先でのパスを計算
    local rel_path="${host_full_path#$base_dir}"
    rel_path="${rel_path#/}"
    local container_path="$mount_dst/$rel_path"

    __aicontainer_add_ignore_entry "$host_full_path" "$container_path" "$container_path"
  done < "$aiignore_file"
}

# ディレクトリ内の.aiignoreを再帰的に処理
__aicontainer_find_and_process_aiignores() {
  local src_dir="$1"
  local mount_dst="$2"

  while read -r aiignore_file; do
    __aicontainer_process_aiignore_file "$aiignore_file" "$src_dir" "$mount_dst"
  done < <(find "$src_dir" -name .aiignore -type f)
}

aicontainer() {
  # モードに応じてディレクトリを決定
  local ai_dir=".claude.local"
  if [ "$1" = "ollama" ]; then
    ai_dir=".claude.ollama"
  elif [ "$1" = "codex" ]; then
    ai_dir=".codex.local"
  fi

  mkdir -p "$ai_dir"
  if [ "$1" != "codex" ]; then
    [ ! -f "$ai_dir/.claude.json" ] && echo '{}' > "$ai_dir/.claude.json" || true
    mkdir -p "$ai_dir/.claude"
  fi

  # .envファイルを読み込んで環境変数として設定（docker-compose.ymlと同様の挙動）
  if [ -f .env ]; then
    echo "found .env: loading environment variables..."
    while IFS= read -r line || [ -n "$line" ]; do
      # CRを除去
      line="${line%$'\r'}"
      # 空行をスキップ
      [ -z "$line" ] && continue
      # コメント行をスキップ
      [[ "$line" =~ ^[[:space:]]*# ]] && continue
      # 空白のみの行をスキップ
      [[ "$line" =~ ^[[:space:]]*$ ]] && continue
      # KEY=VALUE形式かチェック
      if [[ "$line" =~ ^[[:space:]]*([a-zA-Z_][a-zA-Z0-9_]*)[[:space:]]*=[[:space:]]*(.*)[[:space:]]*$ ]]; then
        local key="${BASH_REMATCH[1]}"
        local value="${BASH_REMATCH[2]}"
        # 値のクォートを除去（シングル/ダブル）
        if [[ "$value" =~ ^\"(.*)\"$ ]] || [[ "$value" =~ ^\'(.*)\'$ ]]; then
          value="${BASH_REMATCH[1]}"
        fi
        export "$key=$value"
        echo "  loaded: $key"
      fi
    done < .env
  fi

  AI_IGNORE=""
  declare -A AI_IGNORE_PATHS

  # デフォルトの/workspaceマウント配下の.aiignoreを再帰的に処理
  __aicontainer_find_and_process_aiignores "." "/workspace"

  AI_MOUNT=""

  # .aimountを処理
  if [ -f .aimount ]; then
    while IFS= read -r line || [ -n "$line" ]; do
      line="${line%$'\r'}"
      if [ -z "$line" ]; then
        continue
      fi
      if [[ "$line" =~ ^[[:space:]]*# ]]; then
        continue
      fi

      # 先に環境変数を展開してから:で分割
      local expanded_line
      if ! expanded_line="$(eval echo "$line" 2>&1)"; then
        echo "Error: environment variable error: $line" >&2
        echo "  $expanded_line" >&2
        return 1
      fi

      # 展開後の行を:で分割
      IFS=':' read -r src dst <<< "$expanded_line"
      if [ -z "$src" ] || [ -z "$dst" ]; then
        echo "Error: invalid format (expected 'src:dst'): $line" >&2
        return 1
      fi

      # 相対パスを絶対パスに変換し、パスを正規化
      [[ ! "$src" =~ ^/ ]] && src="$(pwd)/$src"

      if [ ! -e "$src" ]; then
        echo "skip mount (not exists): $src"
        return 1
      fi

      src="$(realpath "$src")"

      AI_MOUNT="$AI_MOUNT \\
    --mount type=bind,source=$src,target=$dst"
      echo "mount: $src -> $dst"

      # マウント元ディレクトリ内の.aiignoreを処理
      [ -d "$src" ] && __aicontainer_find_and_process_aiignores "$src" "$dst"
    done < .aimount
  fi

  # 引数チェック
  local dump_mode=false
  local cmd="claude --dangerously-skip-permissions"
  local network="yumayo-ai"
  local extra_env=""
  local extra_opts="--cap-add=NET_ADMIN --cap-add=NET_RAW"
  local shell_prefix="bash"

  if [ "$1" = "dump" ]; then
    dump_mode=true
  elif [ "$1" = "ollama" ]; then
    local model="${2:-}"
    if [ -z "$model" ]; then
      echo "Error: model name required. Usage: aicontainer ollama <model>" >&2
      return 1
    fi
    cmd="claude --dangerously-skip-permissions --model $model"
    extra_env="-e ANTHROPIC_AUTH_TOKEN=ollama -e ANTHROPIC_BASE_URL=http://ollama:11434"
    # https://github.com/yumayo/nginx-open-webui-ollama
    # ネットワークを切り替えています。
    # 完全ローカルで動作させるため、ollamaコンテナで動作させます。
    network="nginx-open-webui-ollama_internal_net"
    extra_opts="--entrypoint bash"
    shell_prefix=""
  elif [ "$1" = "codex" ]; then
    # codex-cli (OpenAI Codex CLI)
    # 認証方法:
    #   1. ChatGPTアカウントでサインイン（Plus/Pro/Business/Enterprise契約者）
    #   2. OPENAI_API_KEYで認証（従量課金）
    # 初回起動時にcodex側でサインインを求められます
    cmd="codex --full-auto"
    extra_env="-e FIREWALL_MODE=codex"
    if [ -n "$OPENAI_API_KEY" ]; then
      extra_env="$extra_env -e OPENAI_API_KEY=$OPENAI_API_KEY"
    fi
  elif [ -n "$1" ]; then
    cmd="$1"
  fi

  # dockerコマンドを構築
  local session_mounts=""
  if [ "$1" = "codex" ]; then
    session_mounts="--mount type=tmpfs,target=/workspace/$ai_dir,tmpfs-size=0 \\
    --mount type=bind,source=\"$(pwd)/$ai_dir\",target=/home/ubuntu/.codex"
  else
    session_mounts="--mount type=tmpfs,target=/workspace/$ai_dir,tmpfs-size=0 \\
    --mount type=bind,source=\"$(pwd)/$ai_dir/.claude\",target=/home/ubuntu/.claude \\
    --mount type=bind,source=\"$(pwd)/$ai_dir/.claude.json\",target=/home/ubuntu/.claude.json"
  fi

  local docker_cmd="docker run -ti --rm \\
    --stop-timeout 0 \\
    --network $network \\
    $extra_env \\
    $extra_opts \\
    --mount type=bind,source=\"$(pwd)\",target=/workspace \\
    $session_mounts$AI_MOUNT$AI_IGNORE \\
    yumayo-ai \\
    $shell_prefix -ci \"$cmd\""

  if [ "$dump_mode" = true ]; then
    echo "$docker_cmd"
  else
    eval "$docker_cmd"
  fi
}
