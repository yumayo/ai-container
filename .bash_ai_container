#!/bin/bash

# 1つのエントリーをAI_IGNOREに追加
__aicontainer_add_ignore_entry() {
  local host_path="$1"
  local container_path="$2"
  local message="$3"

  # 重複チェック
  if [ -n "${AI_IGNORE_PATHS[$container_path]}" ]; then
    echo "ignored (already): $message"
    return
  fi

  if [ -d "$host_path" ]; then
    AI_IGNORE="$AI_IGNORE \\
    --mount type=tmpfs,target=$container_path,tmpfs-size=0"
    AI_IGNORE_PATHS[$container_path]=1
    echo "ignored: $message"
  elif [ -f "$host_path" ]; then
    AI_IGNORE="$AI_IGNORE \\
    --mount type=bind,source=/dev/null,target=$container_path,readonly"
    AI_IGNORE_PATHS[$container_path]=1
    echo "ignored: $message"
  fi
}

# .aiignoreファイルを処理（base_dirとmount_dstを指定）
__aicontainer_process_aiignore_file() {
  local aiignore_file="$1"
  local base_dir="$2"
  local mount_dst="$3"

  echo "found .aiignore: $aiignore_file"

  local aiignore_dir="$(dirname "$aiignore_file")"

  while IFS= read -r line || [ -n "$line" ]; do
    line="${line%$'\r'}"

    # 空行とコメント行をスキップ
    if [ -z "$line" ]; then
      continue
    fi
    if [[ "$line" =~ ^[[:space:]]*# ]]; then
      continue
    fi

    # パスの正規化
    line="${line#/}"
    local host_full_path="$aiignore_dir/$line"

    # マウント先でのパスを計算
    local rel_path="${host_full_path#$base_dir}"
    rel_path="${rel_path#/}"
    local container_path="$mount_dst/$rel_path"

    __aicontainer_add_ignore_entry "$host_full_path" "$container_path" "$container_path"
  done < "$aiignore_file"
}

# ディレクトリ内の.aiignoreを再帰的に処理
__aicontainer_find_and_process_aiignores() {
  local src_dir="$1"
  local mount_dst="$2"

  while read -r aiignore_file; do
    __aicontainer_process_aiignore_file "$aiignore_file" "$src_dir" "$mount_dst"
  done < <(find "$src_dir" -name .aiignore -type f)
}

aicontainer() {
  mkdir -p .claude.local
  [ ! -f .claude.local/.claude.json ] && echo '{}' > .claude.local/.claude.json || true
  mkdir -p .claude.local/.claude

  AI_IGNORE=""
  declare -A AI_IGNORE_PATHS

  # デフォルトの/workspaceマウント配下の.aiignoreを再帰的に処理
  __aicontainer_find_and_process_aiignores "." "/workspace"

  AI_MOUNT=""

  # .aimountを処理
  if [ -f .aimount ]; then
    while IFS= read -r line || [ -n "$line" ]; do
      line="${line%$'\r'}"
      if [ -z "$line" ]; then
        continue
      fi
      if [[ "$line" =~ ^[[:space:]]*# ]]; then
        continue
      fi

      # 先に環境変数を展開してから:で分割
      local expanded_line
      if ! expanded_line="$(eval echo "$line" 2>&1)"; then
        echo "Error: environment variable error: $line" >&2
        echo "  $expanded_line" >&2
        return 1
      fi

      # 展開後の行を:で分割
      IFS=':' read -r src dst <<< "$expanded_line"
      if [ -z "$src" ] || [ -z "$dst" ]; then
        echo "Error: invalid format (expected 'src:dst'): $line" >&2
        return 1
      fi

      # 相対パスを絶対パスに変換し、パスを正規化
      [[ ! "$src" =~ ^/ ]] && src="$(pwd)/$src"

      if [ ! -e "$src" ]; then
        echo "skip mount (not exists): $src"
        return 1
      fi

      src="$(realpath "$src")"

      AI_MOUNT="$AI_MOUNT \\
    --mount type=bind,source=$src,target=$dst"
      echo "mount: $src -> $dst"

      # マウント元ディレクトリ内の.aiignoreを処理
      [ -d "$src" ] && __aicontainer_find_and_process_aiignores "$src" "$dst"
    done < .aimount
  fi

  # 引数チェック
  local dump_mode=false
  local cmd="claude --dangerously-skip-permissions"

  if [ "$1" = "dump" ]; then
    dump_mode=true
  elif [ -n "$1" ]; then
    cmd="$1"
  fi

  # dockerコマンドを構築
  local docker_cmd="docker run -ti --rm \\
    --stop-timeout 0 \\
    --cap-add=NET_ADMIN \\
    --cap-add=NET_RAW \\
    --mount type=bind,source=\"$(pwd)\",target=/workspace \\
    --mount type=tmpfs,target=/workspace/.claude.local,tmpfs-size=0 \\
    --mount type=bind,source=\"$(pwd)/.claude.local/.claude\",target=/home/ubuntu/.claude \\
    --mount type=bind,source=\"$(pwd)/.claude.local/.claude.json\",target=/home/ubuntu/.claude.json$AI_MOUNT$AI_IGNORE \\
    yumayo-ai \\
    bash -ci \"$cmd\""

  if [ "$dump_mode" = true ]; then
    echo "$docker_cmd"
  else
    eval "$docker_cmd"
  fi
}
